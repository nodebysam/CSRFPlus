/**
 * CSRF Plus
 * Next-level protection against forged requests
 * 
 * @author Sam Wilcox aka NodeBySam
 * @github https://github.com/nodebysam/CSRFPlus
 * 
 * CSRF Plus is released under the MIT license.
 * See the LICENSE file in the root of this
 * library's path.
 */

const { encode, decode } = require('../utils/b64url');
const { randomBytes } = require('../utils/cryptoHelpers');

/**
 * Creates a masked CSRF token from a new secret buffer.
 * 
 * @param {Buffer} secretBuf - The original secret value stored server-side. Must be
 *                             `Buffer` or fixed length (typically 32 bytes).
 * @returns {string} A Base64-URL-encoded string containing the mask and masked secret.
 *                   Safe to include in HTML forms and headers.
 */
const makeMaskedToken = (secretBuf) => {
    const mask = randomBytes(secretBuf.length);
    const masked = Buffer.alloc(secretBuf.length);
    for (let i = 0; i < secretBuf.length; i++) masked[i] = mask[i] ^ secretBuf[i];
    return encode(Buffer.concat([mask, masked]));
};

/**
 * Decodes a masked token produced by `makeMaskedToken()` and reconstructs the original
 * secret. This is done server-side when validating CSRF submissions.
 * 
 * @param {string} maskedB64 - A Base64-URL-encoded masked token previously generated by `makeMaskedToken()`.
 * @returns {Buffer} The recovered original secret buffer.
 */
const unmaskToken = (maskedB64) => {
    const buf = decode(maskedB64);
    if (buf.length % 2 !== 0) throw new Error('Invalid masked token length.');
    const half = buf.length / 2;
    const mask = buf.slice(0, half);
    const masked = buf.slice(half);
    const secret = Buffer.alloc(half);
    for (let i = 0; i < half; i++) secret[i] = mask[i] ^ masked[i];
    return secret;
};

module.exports = { makeMaskedToken, unmaskToken };